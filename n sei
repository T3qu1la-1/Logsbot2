import asyncio
import logging
import os
import time
import hashlib
import shutil
import re
import sqlite3
import uuid
from datetime import datetime, timedelta
from typing import Dict, Set, Optional, List, Tuple
from telethon import TelegramClient, events, Button
from telethon.tl.functions.users import GetFullUserRequest
from telethon.tl.types import DocumentAttributeFilename
from telethon.utils import get_display_name
from telethon.errors import UserIsBlockedError
import nest_asyncio

# Corrige problemas de event loop
nest_asyncio.apply()

# ConfiguraÃ§Ã£o de logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# ConfiguraÃ§Ãµes do bot
API_ID = 25317254
API_HASH = 'bef2f48bb6b4120c9189ecfd974eb820'
BOT_TOKEN = '7369466703:AAHALdZSqvCVkfyhs6sW-JoHkrnX0r9e7Rw'
SUPPORT_CHAT = '@darack_support'
ADMIN_ID = 6919117453  # ID do administrador principal

# ConfiguraÃ§Ãµes de diretÃ³rios
DB_PATH = "./database/bot_data.db"
TEMP_DIR = "./temp_files"
RESULTS_DIR = "./results"
BANNER_PATH = "./assets/banner_start.png"

# Criar diretÃ³rios necessÃ¡rios
os.makedirs(TEMP_DIR, exist_ok=True)
os.makedirs(RESULTS_DIR, exist_ok=True)
os.makedirs(os.path.dirname(DB_PATH), exist_ok=True)

# Lista de administradores
ADMINS = [ADMIN_ID, 123456789]  # Adicione mais IDs conforme necessÃ¡rio

# VariÃ¡veis globais
usuarios_bloqueados: Set[int] = set()
usuarios_autorizados: Dict[int, str] = {}
mensagens_origem: Dict[int, int] = {}
urls_busca: Dict[int, str] = {}
tasks_canceladas: Dict[str, Dict[str, bool]] = {}
affiliate_codes: Dict[str, int] = {}  # cÃ³digo -> user_id

class Database:
    def __init__(self):
        self.db_path = DB_PATH
        self.init_db()

    def init_db(self):
        """Inicializa o banco de dados"""
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.cursor()

            # Tabela de usuÃ¡rios
            cursor.execute('''CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY,
                username TEXT,
                first_name TEXT,
                last_name TEXT,
                hash TEXT,
                created_at TEXT,
                expires_at TEXT,
                plan_type TEXT DEFAULT 'free',
                is_authorized BOOLEAN DEFAULT FALSE,
                is_banned BOOLEAN DEFAULT FALSE,
                is_admin BOOLEAN DEFAULT FALSE,
                search_count INTEGER DEFAULT 0,
                last_activity TEXT,
                affiliate_code TEXT,
                referrer_id INTEGER,
                commission_earned REAL DEFAULT 0.0,
                commission_paid REAL DEFAULT 0.0
            )''')

            # Tabela de tokens
            cursor.execute('''CREATE TABLE IF NOT EXISTS tokens (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                token TEXT UNIQUE,
                plan_type TEXT,
                duration_days INTEGER,
                is_used BOOLEAN DEFAULT FALSE,
                used_by INTEGER,
                created_at TEXT,
                used_at TEXT
            )''')

            # Tabela de buscas
            cursor.execute('''CREATE TABLE IF NOT EXISTS searches (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                domain TEXT,
                results_count INTEGER,
                search_date TEXT,
                FOREIGN KEY (user_id) REFERENCES users (id)
            )''')

            # Tabela de arquivos processados
            cursor.execute('''CREATE TABLE IF NOT EXISTS processed_files (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                filename TEXT,
                processed_lines INTEGER,
                unique_domains INTEGER,
                processed_at TEXT
            )''')

            conn.commit()

class UserManager:
    def __init__(self, db: Database):
        self.db = db

    async def register_user(self, user_id: int, username: str = None, 
                          first_name: str = None, last_name: str = None):
        """Registra um usuÃ¡rio no banco de dados"""
        user_hash = hashlib.md5(f"{first_name or ''}{user_id}".encode()).hexdigest()[:8]
        now = datetime.now().isoformat()

        # Gera cÃ³digo de afiliado Ãºnico
        affiliate_code = str(uuid.uuid4())[:8]

        with sqlite3.connect(self.db.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute('''INSERT OR IGNORE INTO users 
                (id, username, first_name, last_name, hash, created_at, affiliate_code)
                VALUES (?, ?, ?, ?, ?, ?, ?)''',
                (user_id, username, first_name, last_name, user_hash, now, affiliate_code))
            conn.commit()

    async def get_user_info(self, user_id: int) -> Optional[Dict]:
        """ObtÃ©m informaÃ§Ãµes do usuÃ¡rio"""
        with sqlite3.connect(self.db.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM users WHERE id = ?", (user_id,))
            row = cursor.fetchone()

            if row:
                return {
                    'id': row[0],
                    'username': row[1],
                    'first_name': row[2],
                    'last_name': row[3],
                    'hash': row[4],
                    'created_at': row[5],
                    'expires_at': row[6],
                    'plan_type': row[7],
                    'is_authorized': bool(row[8]),
                    'is_banned': bool(row[9]),
                    'is_admin': bool(row[10]),
                    'search_count': row[11],
                    'last_activity': row[12],
                    'affiliate_code': row[13],
                    'referrer_id': row[14],
                    'commission_earned': row[15],
                    'commission_paid': row[16]
                }
        return None

    async def is_authorized(self, user_id: int) -> bool:
        """Verifica se o usuÃ¡rio estÃ¡ autorizado"""
        user_info = await self.get_user_info(user_id)
        if not user_info:
            return False

        if user_info['is_admin']:
            return True

        if not user_info['is_authorized']:
            return False

        # Verifica se o plano ainda estÃ¡ vÃ¡lido
        if user_info['expires_at']:
            expires_at = datetime.fromisoformat(user_info['expires_at'])
            if datetime.now() > expires_at:
                # Plano expirado
                with sqlite3.connect(self.db.db_path) as conn:
                    cursor = conn.cursor()
                    cursor.execute(
                        "UPDATE users SET is_authorized = FALSE, plan_type = 'free' WHERE id = ?",
                        (user_id,)
                    )
                    conn.commit()
                return False

        return True

    async def update_search_count(self, user_id: int):
        """Atualiza contador de buscas do usuÃ¡rio"""
        with sqlite3.connect(self.db.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute(
                "UPDATE users SET search_count = search_count + 1, last_activity = ? WHERE id = ?",
                (datetime.now().isoformat(), user_id)
            )
            conn.commit()

class TokenManager:
    def __init__(self, db: Database):
        self.db = db

    async def generate_token(self, plan_type: str, duration_days: int) -> str:
        """Gera um novo token"""
        token = str(uuid.uuid4())
        now = datetime.now().isoformat()

        with sqlite3.connect(self.db.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute('''INSERT INTO tokens 
                (token, plan_type, duration_days, created_at)
                VALUES (?, ?, ?, ?)''',
                (token, plan_type, duration_days, now))
            conn.commit()

        return token

    async def redeem_token(self, token: str, user_id: int) -> Dict:
        """Resgata um token"""
        with sqlite3.connect(self.db.db_path) as conn:
            cursor = conn.cursor()

            # Verifica se o token existe e nÃ£o foi usado
            cursor.execute("SELECT * FROM tokens WHERE token = ? AND is_used = FALSE", (token,))
            token_info = cursor.fetchone()

            if not token_info:
                return {'success': False, 'message': 'Token invÃ¡lido ou jÃ¡ utilizado'}

            # Calcula data de expiraÃ§Ã£o
            expires_at = datetime.now() + timedelta(days=token_info[3])

            # Atualiza o usuÃ¡rio
            cursor.execute('''UPDATE users SET 
                is_authorized = TRUE, 
                plan_type = ?, 
                expires_at = ? 
                WHERE id = ?''',
                (token_info[2], expires_at.isoformat(), user_id))

            # Marca o token como usado
            cursor.execute('''UPDATE tokens SET 
                is_used = TRUE, 
                used_by = ?, 
                used_at = ? 
                WHERE token = ?''',
                (user_id, datetime.now().isoformat(), token))

            conn.commit()

            return {
                'success': True,
                'plan_type': token_info[2],
                'expires_at': expires_at.strftime('%d/%m/%Y %H:%M')
            }

class SearchManager:
    def __init__(self, db: Database):
        self.db = db

    def validate_domain(self, domain: str) -> bool:
        """Valida se o domÃ­nio Ã© vÃ¡lido"""
        if not domain or not domain.strip():
            return False

        domain = domain.strip()
        if ' ' in domain:
            return False

        # Remove protocolo se presente
        if domain.startswith(('http://', 'https://')):
            domain = domain.split('://', 1)[1]

        # PadrÃ£o bÃ¡sico de validaÃ§Ã£o de domÃ­nio
        pattern = re.compile(
            r'^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$'
        )

        return bool(pattern.match(domain))

    async def search_domain(self, domain: str, user_id: int, callback=None) -> Dict:
        """Realiza busca no domÃ­nio"""
        if not self.validate_domain(domain):
            return {'success': False, 'message': 'DomÃ­nio invÃ¡lido'}

        # Cria pasta temporÃ¡ria para o usuÃ¡rio
        user_temp_dir = os.path.join(TEMP_DIR, str(user_id))
        os.makedirs(user_temp_dir, exist_ok=True)

        # Simula busca de dados (substitua pela implementaÃ§Ã£o real)
        await self.simulate_search(domain, user_id, user_temp_dir, callback)

        # Verifica se encontrou resultados
        raw_file = os.path.join(user_temp_dir, f"{user_id}.txt")
        formatted_file = os.path.join(user_temp_dir, f"{user_id}_formatted.txt")

        if not os.path.exists(raw_file):
            return {'success': False, 'message': 'Nenhum resultado encontrado'}

        # Conta resultados
        with open(raw_file, 'r', encoding='utf-8') as f:
            count = sum(1 for line in f if line.strip())

        if count == 0:
            return {'success': False, 'message': 'Nenhum resultado encontrado'}

        # Registra a busca
        with sqlite3.connect(self.db.db_path) as conn:
            cursor = conn.cursor()
            cursor.execute('''INSERT INTO searches 
                (user_id, domain, results_count, search_date)
                VALUES (?, ?, ?, ?)''',
                (user_id, domain, count, datetime.now().isoformat()))
            conn.commit()

        return {
            'success': True,
            'count': count,
            'raw_file': raw_file,
            'formatted_file': formatted_file,
            'domain': domain
        }

    async def simulate_search(self, domain: str, user_id: int, temp_dir: str, callback=None):
        """Simula busca de dados - substitua pela implementaÃ§Ã£o real"""
        # Dados fictÃ­cios para demonstraÃ§Ã£o
        mock_data = [
            f"user1@{domain}:password123",
            f"user2@{domain}:password456",
            f"admin@{domain}:admin123",
            f"test@{domain}:test456",
            f"support@{domain}:support789"
        ]

        # Simula progresso
        for i in range(100):
            if callback:
                callback(i)
            await asyncio.sleep(0.05)  # Simula processamento

        # Cria arquivo bruto
        raw_file = os.path.join(temp_dir, f"{user_id}.txt")
        with open(raw_file, 'w', encoding='utf-8') as f:
            f.write('\n'.join(mock_data))

        # Cria arquivo formatado
        formatted_file = os.path.join(temp_dir, f"{user_id}_formatted.txt")
        with open(formatted_file, 'w', encoding='utf-8') as f:
            for line in mock_data:
                if ':' in line:
                    email, password = line.split(':', 1)
                    f.write(f"Email: {email}\nSenha: {password}\n{'='*40}\n")

class DarackBot:
    def __init__(self):
        self.client = TelegramClient('darack_bot', API_ID, API_HASH)
        self.db = Database()
        self.user_manager = UserManager(self.db)
        self.token_manager = TokenManager(self.db)
        self.search_manager = SearchManager(self.db)

        # Registra handlers
        self.register_handlers()

    def register_handlers(self):
        """Registra todos os handlers do bot"""

        @self.client.on(events.NewMessage(pattern=r'^/start$'))
        async def start_handler(event):
            await self.handle_start(event)

        @self.client.on(events.NewMessage(pattern=r'^/start aff_(.+)'))
        async def start_affiliate_handler(event):
            await self.handle_start_affiliate(event)

        @self.client.on(events.NewMessage(pattern=r'^/search (.+)'))
        async def search_handler(event):
            await self.handle_search(event)

        @self.client.on(events.NewMessage(pattern=r'^/resgatar (.+)'))
        async def redeem_handler(event):
            await self.handle_redeem_token(event)

        @self.client.on(events.NewMessage(pattern=r'^/reset$'))
        async def reset_handler(event):
            await self.handle_reset(event)

        @self.client.on(events.NewMessage(pattern=r'^/afiliado$'))
        async def affiliate_handler(event):
            await self.handle_affiliate(event)

        # Comandos administrativos
        @self.client.on(events.NewMessage(pattern=r'^/gerar_token (\w+) (\d+)$'))
        async def generate_token_handler(event):
            await self.handle_generate_token(event)

        @self.client.on(events.NewMessage(pattern=r'^/autorizar (\d+) (\d+)$'))
        async def authorize_handler(event):
            await self.handle_authorize_user(event)

        @self.client.on(events.NewMessage(pattern=r'^/info (\d+)$'))
        async def info_handler(event):
            await self.handle_user_info(event)

        @self.client.on(events.CallbackQuery)
        async def callback_handler(event):
            await self.handle_callback(event)

    async def handle_start(self, event):
        """Handler para comando /start"""
        try:
            user = await self.client(GetFullUserRequest(event.sender_id))
            u = user.users[0]

            # Registra o usuÃ¡rio
            await self.user_manager.register_user(
                user_id=u.id,
                username=u.username,
                first_name=u.first_name,
                last_name=u.last_name
            )

            user_info = await self.user_manager.get_user_info(u.id)
            mention = f"[{get_display_name(u)}](tg://user?id={u.id})"

            # Determina o status do usuÃ¡rio
            if user_info['is_admin']:
                status = "ADMINISTRADOR"
                buttons = await self.create_admin_menu(u.id)
            elif user_info['is_authorized']:
                status = user_info['plan_type'].upper()
                buttons = await self.create_user_menu(u.id)
            else:
                status = "USUÃRIO LIVRE"
                buttons = await self.create_free_menu(u.id)

            welcome_text = f"""**ğŸ”¥ BEM-VINDO AO BOT DARACK!**

ğŸ‘¤ **UsuÃ¡rio:** {mention}
ğŸ“Š **Status:** {status}
â° **Expira em:** {user_info['expires_at'] or 'NÃ£o definido'}

ğŸ¯ **Sobre o Bot:**
O Bot Darack Ã© sua ferramenta profissional para busca de dados de login. Oferecemos acesso a milhares de domÃ­nios com dados atualizados regularmente.

ğŸ’ **Funcionalidades:**
â€¢ Busca avanÃ§ada por domÃ­nios
â€¢ Sistema de afiliaÃ§Ã£o com comissÃµes
â€¢ Suporte tÃ©cnico especializado
â€¢ AtualizaÃ§Ãµes constantes da base de dados

ğŸ’¡ **Aproveite o sistema de forma justa e responsÃ¡vel!**

ğŸ“ **Suporte:** {SUPPORT_CHAT}

ğŸ¤– @DarackServerRobot"""

            if os.path.exists(BANNER_PATH):
                await self.client.send_file(
                    event.chat_id,
                    file=BANNER_PATH,
                    caption=welcome_text,
                    buttons=buttons,
                    reply_to=event.id
                )
            else:
                await event.respond(welcome_text, buttons=buttons)

        except Exception as e:
            logger.error(f"Erro no start_handler: {e}")
            await event.respond("âŒ Erro interno. Tente novamente.")

    async def handle_start_affiliate(self, event):
        """Handler para links de afiliaÃ§Ã£o"""
        affiliate_code = event.pattern_match.group(1)
        # Implementar lÃ³gica de afiliaÃ§Ã£o aqui
        await self.handle_start(event)

    async def handle_search(self, event):
        """Handler para busca de domÃ­nios"""
        try:
            domain = event.pattern_match.group(1).strip()
            user_id = event.sender_id

            # Verifica autorizaÃ§Ã£o
            if not await self.user_manager.is_authorized(user_id):
                await event.respond(
                    "âŒ **ACESSO NEGADO!**\n\n"
                    "VocÃª precisa de um plano ativo para realizar buscas.\n"
                    "Use `/start` para ver as opÃ§Ãµes disponÃ­veis.",
                    buttons=[[Button.inline("âŒ | APAGAR", data=f"delete:{user_id}")]]
                )
                return

            # Verifica se nÃ£o estÃ¡ bloqueado
            if user_id in usuarios_bloqueados:
                await event.respond(
                    "â›” **AGUARDE ATÃ‰ QUE A PESQUISA SEJA CONCLUÃDA!**\n\n"
                    "Use `/reset` para resetar suas informaÃ§Ãµes.\n\n"
                    "ğŸ¤– @DarackServerRobot",
                    buttons=[[Button.inline("âŒ | APAGAR", data=f"delete:{user_id}")]]
                )
                return

            # Valida domÃ­nio
            if not self.search_manager.validate_domain(domain):
                await event.respond(
                    "âŒ **DOMÃNIO INVÃLIDO!**\n\n"
                    "Exemplo: `/search google.com`\n\n"
                    "ğŸ¤– @DarackServerRobot",
                    buttons=[[Button.inline("âŒ | APAGAR", data=f"delete:{user_id}")]]
                )
                return

            # Bloqueia usuÃ¡rio durante busca
            usuarios_bloqueados.add(user_id)
            mensagens_origem[user_id] = event.id
            urls_busca[user_id] = domain

            hash_nome = str(user_id)
            tasks_canceladas[hash_nome] = {'cancelled': False}

            # Mensagem de progresso
            progress_msg = await event.respond(
                "**â˜ï¸ | PROCURANDO DADOS...**\n\n"
                f"**ğŸ” DomÃ­nio:** `{domain}`\n"
                f"**[â™¦ï¸] Logins encontrados:** `0`\n\n"
                "ğŸ¤– @DarackServerRobot",
                buttons=[
                    [Button.inline("ğŸš« | PARAR", data=f"cancel_search:{user_id}")],
                    [Button.inline("âŒ | APAGAR", data=f"delete:{user_id}")]
                ]
            )

            # Callback para atualizar progresso
            contador = 0

            def update_counter(value):
                nonlocal contador
                contador = value

            # Tarefa para atualizar mensagem
            async def update_progress():
                while not tasks_canceladas[hash_nome]['cancelled']:
                    try:
                        await progress_msg.edit(
                            f"**â˜ï¸ | PROCURANDO DADOS...**\n\n"
                            f"**ğŸ” DomÃ­nio:** `{domain}`\n"
                            f"**[â™¦ï¸] Logins encontrados:** `{contador}`\n\n"
                            "ğŸ¤– @DarackServerRobot",
                            buttons=[
                                [Button.inline("ğŸš« | PARAR", data=f"cancel_search:{user_id}")],
                                [Button.inline("âŒ | APAGAR", data=f"delete:{user_id}")]
                            ]
                        )
                        await asyncio.sleep(2)
                    except Exception:
                        break

            # Inicia busca
            update_task = asyncio.create_task(update_progress())

            result = await self.search_manager.search_domain(domain, user_id, update_counter)

            # Cancela tarefa de atualizaÃ§Ã£o
            tasks_canceladas[hash_nome]['cancelled'] = True
            update_task.cancel()

            if not result['success']:
                await progress_msg.edit(
                    f"âŒ **NENHUM RESULTADO ENCONTRADO!**\n\n"
                    f"**ğŸ” DomÃ­nio:** `{domain}`\n\n"
                    "ğŸ¤– @DarackServerRobot",
                    buttons=[[Button.inline("âŒ | APAGAR", data=f"delete:{user_id}")]]
                )
                usuarios_bloqueados.discard(user_id)
                return

            # Atualiza contador de buscas
            await self.user_manager.update_search_count(user_id)

            # Mostra opÃ§Ãµes de formato
            await progress_msg.edit(
                f"**â˜ï¸ | RESULTADOS ENCONTRADOS: {result['count']}**\n\n"
                f"**ğŸ” DomÃ­nio:** `{domain}`\n"
                f"**QUAL FORMATO VOCÃŠ ESCOLHE:**\n\n"
                "ğŸ¤– @DarackServerRobot",
                buttons=[
                    [
                        Button.inline("ğŸ”» | USER:PASS", data=f"format_raw:{user_id}"),
                        Button.inline("ğŸ“„ | FORMATADO", data=f"format_formatted:{user_id}")
                    ],
                    [Button.inline("âŒ | CANCELAR", data=f"cancel_result:{user_id}")]
                ]
            )

            usuarios_bloqueados.discard(user_id)

        except Exception as e:
            logger.error(f"Erro na busca: {e}")
            usuarios_bloqueados.discard(user_id)
            await event.respond("âŒ Erro interno durante a busca.")

    async def handle_redeem_token(self, event):
        """Handler para resgate de tokens"""
        try:
            token = event.pattern_match.group(1).strip()
            user_id = event.sender_id

            result = await self.token_manager.redeem_token(token, user_id)

            if result['success']:
                await event.respond(
                    f"âœ… **TOKEN RESGATADO COM SUCESSO!**\n\n"
                    f"ğŸ **Plano:** {result['plan_type'].upper()}\n"
                    f"â° **VÃ¡lido atÃ©:** {result['expires_at']}\n\n"
                    f"Agora vocÃª tem acesso completo ao bot!\n\n"
                    "ğŸ¤– @DarackServerRobot",
                    buttons=[[Button.inline("âŒ | APAGAR", data=f"delete:{user_id}")]]
                )
            else:
                await event.respond(
                    f"âŒ **ERRO AO RESGATAR TOKEN:**\n\n"
                    f"{result['message']}\n\n"
                    "ğŸ¤– @DarackServerRobot",
                    buttons=[[Button.inline("âŒ | APAGAR", data=f"delete:{user_id}")]]
                )

        except Exception as e:
            logger.error(f"Erro no resgate de token: {e}")
            await event.respond("âŒ Erro interno ao resgatar token.")

    async def handle_reset(self, event):
        """Handler para reset de dados do usuÃ¡rio"""
        try:
            user_id = event.sender_id
            hash_nome = str(user_id)

            # Limpa dados do usuÃ¡rio
            tasks_canceladas.pop(hash_nome, None)
            usuarios_bloqueados.discard(user_id)
            usuarios_autorizados.pop(user_id, None)
            mensagens_origem.pop(user_id, None)
            urls_busca.pop(user_id, None)

            # Remove pasta temporÃ¡ria
            user_temp_dir = os.path.join(TEMP_DIR, str(user_id))
            if os.path.exists(user_temp_dir):
                shutil.rmtree(user_temp_dir, ignore_errors=True)

            await event.respond(
                "âœ… **DADOS RESETADOS COM SUCESSO!**\n\n"
                "Agora vocÃª pode utilizar os comandos novamente.\n\n"
                "ğŸ¤– @DarackServerRobot",
                buttons=[[Button.inline("âŒ | APAGAR", data=f"delete:{user_id}")]]
            )

        except Exception as e:
            logger.error(f"Erro no reset: {e}")
            await event.respond("âŒ Erro ao resetar dados.")

    async def handle_affiliate(self, event):
        """Handler para painel de afiliaÃ§Ã£o"""
        try:
            user_id = event.sender_id

            if not await self.user_manager.is_authorized(user_id):
                await event.respond(
                    "âŒ **ACESSO NEGADO!**\n\n"
                    "VocÃª precisa de um plano ativo para acessar o programa de afiliaÃ§Ã£o.",
                    buttons=[[Button.inline("âŒ | APAGAR", data=f"delete:{user_id}")]]
                )
                return

            user_info = await self.user_manager.get_user_info(user_id)
            bot_info = await self.client.get_me()

            affiliate_text = f"""ğŸ’° **PAINEL DE AFILIAÃ‡ÃƒO**

ğŸ‘¥ **Seus NÃºmeros:**
â€¢ CÃ³digo: `{user_info['affiliate_code']}`
â€¢ ComissÃµes acumuladas: R$ {user_info['commission_earned']:.2f}
â€¢ ComissÃµes pagas: R$ {user_info['commission_paid']:.2f}

ğŸ”— **Seu Link:**
`https://t.me/{bot_info.username}?start=aff_{user_info['affiliate_code']}`

ğŸ“Š **Como Funciona:**
â€¢ Compartilhe seu link
â€¢ Ganhe 30% por cada venda
â€¢ Saque mÃ­nimo: R$ 50,00
â€¢ Pagamento via PIX em 48h

ğŸ¤– @DarackServerRobot"""

            buttons = [
                [Button.inline("ğŸ’¸ | SOLICITAR SAQUE", data=f"request_payout:{user_id}")],
                [Button.inline("ğŸ“ˆ | ESTATÃSTICAS", data=f"affiliate_stats:{user_id}")],
                [Button.inline("âŒ | APAGAR", data=f"delete:{user_id}")]
            ]

            await event.respond(affiliate_text, buttons=buttons)

        except Exception as e:
            logger.error(f"Erro no painel de afiliaÃ§Ã£o: {e}")
            await event.respond("âŒ Erro interno.")

    async